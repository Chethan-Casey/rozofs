/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "storage_proto.h"
#include "rozo.h"

bool_t
xdr_storage_status_t (XDR *xdrs, storage_status_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_uuid_t (XDR *xdrs, storage_uuid_t objp)
{
	register int32_t *buf;

	 if (!xdr_opaque (xdrs, objp, ROZO_UUID_SIZE))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_status_response_t (XDR *xdrs, storage_status_response_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case STORAGE_FAILURE:
		 if (!xdr_int (xdrs, &objp->storage_status_response_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_storage_remove_args_t (XDR *xdrs, storage_remove_args_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_uuid_t (xdrs, objp->uuid))
		 return FALSE;
	 if (!xdr_storage_uuid_t (xdrs, objp->mf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_write_args_t (XDR *xdrs, storage_write_args_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_uuid_t (xdrs, objp->uuid))
		 return FALSE;
	 if (!xdr_storage_uuid_t (xdrs, objp->mf))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->mp))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->mb))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->nmbs))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->bins.bins_val, (u_int *) &objp->bins.bins_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_read_args_t (XDR *xdrs, storage_read_args_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_uuid_t (xdrs, objp->uuid))
		 return FALSE;
	 if (!xdr_storage_uuid_t (xdrs, objp->mf))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->mp))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->mb))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->nmbs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_truncate_args_t (XDR *xdrs, storage_truncate_args_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_uuid_t (xdrs, objp->uuid))
		 return FALSE;
	 if (!xdr_storage_uuid_t (xdrs, objp->mf))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->mp))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->mb))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_read_response_t (XDR *xdrs, storage_read_response_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case STORAGE_SUCCESS:
		 if (!xdr_bytes (xdrs, (char **)&objp->storage_read_response_t_u.bins.bins_val, (u_int *) &objp->storage_read_response_t_u.bins.bins_len, ~0))
			 return FALSE;
		break;
	case STORAGE_FAILURE:
		 if (!xdr_int (xdrs, &objp->storage_read_response_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_storage_stat_t (XDR *xdrs, storage_stat_t *objp)
{
	register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->bsize))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->bfree))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_storage_stat_response_t (XDR *xdrs, storage_stat_response_t *objp)
{
	register int32_t *buf;

	 if (!xdr_storage_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case STORAGE_SUCCESS:
		 if (!xdr_storage_stat_t (xdrs, &objp->storage_stat_response_t_u.stat))
			 return FALSE;
		break;
	case STORAGE_FAILURE:
		 if (!xdr_int (xdrs, &objp->storage_stat_response_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
