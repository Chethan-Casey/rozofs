/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <rozofs/rozofs.h>

#include "eproto.h"

bool_t
xdr_ep_uuid_t (XDR *xdrs, ep_uuid_t objp)
{
	//register int32_t *buf;

	 if (!xdr_vector (xdrs, (char *)objp, ROZOFS_UUID_SIZE,
		sizeof (u_char), (xdrproc_t) xdr_u_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_name_t (XDR *xdrs, ep_name_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ROZOFS_FILENAME_MAX))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_xattr_name_t (XDR *xdrs, ep_xattr_name_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ROZOFS_XATTR_NAME_MAX))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_xattr_value_t (XDR *xdrs, ep_xattr_value_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ROZOFS_XATTR_VALUE_MAX))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_xattr_list_t (XDR *xdrs, ep_xattr_list_t objp)
{
	//register int32_t *buf;

	 if (!xdr_vector (xdrs, (char *)objp, ROZOFS_XATTR_LIST_MAX,
		sizeof (u_char), (xdrproc_t) xdr_u_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_path_t (XDR *xdrs, ep_path_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ROZOFS_PATH_MAX))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_link_t (XDR *xdrs, ep_link_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ROZOFS_PATH_MAX))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_host_t (XDR *xdrs, ep_host_t objp)
{
	//register int32_t *buf;

	 if (!xdr_vector (xdrs, (char *)objp, ROZOFS_HOSTNAME_MAX,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_md5_t (XDR *xdrs, ep_md5_t objp)
{
	//register int32_t *buf;

	 if (!xdr_vector (xdrs, (char *)objp, ROZOFS_MD5_SIZE,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_status_t (XDR *xdrs, ep_status_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_status_ret_t (XDR *xdrs, ep_status_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_status_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_storage_node_t (XDR *xdrs, ep_storage_node_t *objp)
{
	//register int32_t *buf;

	//int i;
	 if (!xdr_ep_host_t (xdrs, objp->host))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->sids_nb))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->sids, STORAGE_NODE_SIDS_MAX,
		sizeof (uint8_t), (xdrproc_t) xdr_uint8_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_export_t (XDR *xdrs, ep_export_t *objp)
{
	//register int32_t *buf;

	//int i;
	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_md5_t (xdrs, objp->md5))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->rfid))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->rl))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->storage_nodes_nb))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->storage_nodes, STORAGE_NODES_MAX,
		sizeof (ep_storage_node_t), (xdrproc_t) xdr_ep_storage_node_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_mount_ret_t (XDR *xdrs, ep_mount_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_export_t (xdrs, &objp->ep_mount_ret_t_u.export))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_mount_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_mattr_t (XDR *xdrs, ep_mattr_t *objp)
{
	//register int32_t *buf;

	//int i;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_uint16_t (xdrs, &objp->cid))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->sids, ROZOFS_SAFE_MAX,
		sizeof (uint8_t), (xdrproc_t) xdr_uint8_t))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->mode))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->uid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->gid))
		 return FALSE;
	 if (!xdr_uint16_t (xdrs, &objp->nlink))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->ctime))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->atime))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->mtime))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_mattr_ret_t (XDR *xdrs, ep_mattr_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_mattr_t (xdrs, &objp->ep_mattr_ret_t_u.attrs))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_mattr_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_fid_ret_t (XDR *xdrs, ep_fid_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_uuid_t (xdrs, objp->ep_fid_ret_t_u.fid))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_fid_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_lookup_arg_t (XDR *xdrs, ep_lookup_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->parent))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_mfile_arg_t (XDR *xdrs, ep_mfile_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_unlink_arg_t (XDR *xdrs, ep_unlink_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->pfid))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_rmdir_arg_t (XDR *xdrs, ep_rmdir_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->pfid))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_statfs_t (XDR *xdrs, ep_statfs_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint16_t (xdrs, &objp->bsize))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->blocks))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->bfree))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->files))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->ffree))
		 return FALSE;
	 if (!xdr_uint16_t (xdrs, &objp->namemax))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_statfs_ret_t (XDR *xdrs, ep_statfs_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_statfs_t (xdrs, &objp->ep_statfs_ret_t_u.stat))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_statfs_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_setattr_arg_t (XDR *xdrs, ep_setattr_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->to_set))
		 return FALSE;
	 if (!xdr_ep_mattr_t (xdrs, &objp->attrs))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_getattr_ret_t (XDR *xdrs, ep_getattr_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_mattr_t (xdrs, &objp->ep_getattr_ret_t_u.attrs))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_getattr_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_readlink_ret_t (XDR *xdrs, ep_readlink_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_link_t (xdrs, &objp->ep_readlink_ret_t_u.link))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_readlink_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_mknod_arg_t (XDR *xdrs, ep_mknod_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->parent))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->uid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->gid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->mode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_link_arg_t (XDR *xdrs, ep_link_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->inode))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->newparent))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->newname))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_mkdir_arg_t (XDR *xdrs, ep_mkdir_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->parent))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->uid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->gid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->mode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_symlink_arg_t (XDR *xdrs, ep_symlink_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_link_t (xdrs, &objp->link))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->parent))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_children_t (XDR *xdrs, ep_children_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct ep_child_t), (xdrproc_t) xdr_ep_child_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_child_t (XDR *xdrs, ep_child_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_ep_children_t (xdrs, &objp->next))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dirlist_t (XDR *xdrs, dirlist_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_children_t (xdrs, &objp->children))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->eof))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->cookie))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_readdir_arg_t (XDR *xdrs, ep_readdir_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->cookie))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_readdir_ret_t (XDR *xdrs, ep_readdir_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_dirlist_t (xdrs, &objp->ep_readdir_ret_t_u.reply))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_readdir_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_rename_arg_t (XDR *xdrs, ep_rename_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->pfid))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->npfid))
		 return FALSE;
	 if (!xdr_ep_name_t (xdrs, &objp->newname))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_io_arg_t (XDR *xdrs, ep_io_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->length))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_write_block_arg_t (XDR *xdrs, ep_write_block_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->bid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->nrb))
		 return FALSE;
	 if (!xdr_uint16_t (xdrs, &objp->dist))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->length))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_read_t (XDR *xdrs, ep_read_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->dist.dist_val, (u_int *) &objp->dist.dist_len, ~0,
		sizeof (uint16_t), (xdrproc_t) xdr_uint16_t))
		 return FALSE;
	 if (!xdr_int64_t (xdrs, &objp->length))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_read_block_ret_t (XDR *xdrs, ep_read_block_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_read_t (xdrs, &objp->ep_read_block_ret_t_u.ret))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_read_block_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_io_ret_t (XDR *xdrs, ep_io_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_int64_t (xdrs, &objp->ep_io_ret_t_u.length))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_io_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_setxattr_arg_t (XDR *xdrs, ep_setxattr_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_ep_xattr_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->value.value_val, (u_int *) &objp->value.value_len, ~0))
		 return FALSE;
	 if (!xdr_uint8_t (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_getxattr_arg_t (XDR *xdrs, ep_getxattr_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_ep_xattr_name_t (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_getxattr_t (XDR *xdrs, ep_getxattr_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_xattr_value_t (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_getxattr_ret_t (XDR *xdrs, ep_getxattr_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_bytes (xdrs, (char **)&objp->ep_getxattr_ret_t_u.value.value_val, (u_int *) &objp->ep_getxattr_ret_t_u.value.value_len, ~0))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_getxattr_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ep_removexattr_arg_t (XDR *xdrs, ep_removexattr_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_ep_xattr_name_t (xdrs, &objp->name))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_listxattr_arg_t (XDR *xdrs, ep_listxattr_arg_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->eid))
		 return FALSE;
	 if (!xdr_ep_uuid_t (xdrs, objp->fid))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_listxattr_t (XDR *xdrs, ep_listxattr_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_xattr_list_t (xdrs, objp->list))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ep_listxattr_ret_t (XDR *xdrs, ep_listxattr_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_ep_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case EP_SUCCESS:
		 if (!xdr_ep_listxattr_t (xdrs, &objp->ep_listxattr_ret_t_u.ret))
			 return FALSE;
		break;
	case EP_FAILURE:
		 if (!xdr_int (xdrs, &objp->ep_listxattr_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
